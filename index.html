<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Freehand Draw with Snapping & Step-by-Step Ear Clipping</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      margin-bottom: 10px;
      cursor: crosshair;
    }
    #controls button {
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="600" height="400"></canvas>
  <div id="controls">
    <button id="clear">Clear</button>
    <button id="finishDrawing">Finish Drawing</button>
    <button id="nextStep">Next Step</button>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // Global state variables.
    let drawing = false;
    let originalPoints = []; // All freehand-drawn points.
    let polygon = [];        // The working polygon (closed when finished).
    let triangles = [];      // Completed triangles from ear clipping.
    let isSnapped = false;   // True if the mouse is within snapping distance.
    const snapThreshold = 10; // Distance (in pixels) to trigger snapping.

    // Start drawing on mousedown.
    canvas.addEventListener("mousedown", (e) => {
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      originalPoints = [{ x, y }];
      polygon = [{ x, y }];
      isSnapped = false;
      draw();
    });

    // Record freehand points on mousemove.
    canvas.addEventListener("mousemove", (e) => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;
      // Check distance from the first point.
      const start = originalPoints[0];
      const dx = x - start.x;
      const dy = y - start.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < snapThreshold) {
        // Snap current point to the starting point.
        x = start.x;
        y = start.y;
        isSnapped = true;
      } else {
        isSnapped = false;
      }
      // Push the new point.
      originalPoints.push({ x, y });
      polygon.push({ x, y });
      draw();
    });

    // On mouseup, finish the drawingâ€”snapping if appropriate.
    canvas.addEventListener("mouseup", () => {
      drawing = false;
      if (polygon.length > 2) {
        if (isSnapped) {
          // Replace the last point with the first point.
          polygon[polygon.length - 1] = polygon[0];
        } else {
          // Otherwise, explicitly close the polygon.
          polygon.push(polygon[0]);
        }
      }
      draw();
    });

    // "Finish Drawing" button forces closing the polygon.
    document.getElementById("finishDrawing").addEventListener("click", () => {
      if (polygon.length > 2) {
        // If the current endpoint is near the start, snap it.
        const start = polygon[0];
        const last = polygon[polygon.length - 1];
        const dx = last.x - start.x;
        const dy = last.y - start.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < snapThreshold) {
          polygon[polygon.length - 1] = start;
        } else {
          polygon.push(start);
        }
      }
      drawing = false;
      draw();
    });

    // Geometry helper: Compute the signed area of triangle (p, q, r).
    function area(p, q, r) {
      return (q.x - p.x) * (r.y - p.y) - (r.x - p.x) * (q.y - p.y);
    }

    // Check if the angle at 'curr' is convex.
    function isConvex(prev, curr, next) {
      return area(prev, curr, next) < 0;
    }

    // Check if point pt is inside triangle (v1, v2, v3).
    function isPointInTriangle(pt, v1, v2, v3) {
      const d1 = area(pt, v1, v2);
      const d2 = area(pt, v2, v3);
      const d3 = area(pt, v3, v1);
      const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
      const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);
      return !(hasNeg && hasPos);
    }

    // Determine if vertex at index i is an ear.
    // The polygon is expected to be closed (first point repeated at the end).
    function isEar(i, poly) {
      if (poly.length < 4) return false; // Need at least 3 unique vertices.
      const uniquePoly = poly.slice(0, poly.length - 1);
      const len = uniquePoly.length;
      const idx = i;
      const prev = uniquePoly[(idx - 1 + len) % len];
      const curr = uniquePoly[idx];
      const next = uniquePoly[(idx + 1) % len];

      if (!isConvex(prev, curr, next)) return false;

      // Ensure no other vertex lies inside the candidate ear.
      for (let j = 0; j < len; j++) {
        if (j === ((idx - 1 + len) % len) || j === idx || j === ((idx + 1) % len)) {
          continue;
        }
        if (isPointInTriangle(uniquePoly[j], prev, curr, next)) {
          return false;
        }
      }
      return true;
    }

    // Perform one ear clipping step.
    function stepEarClipping() {
      // Ensure we have a closed polygon.
      if (polygon.length < 4) {
        alert("Not enough points to triangulate.");
        return;
      }
      // Work with unique vertices (exclude duplicate last point).
      let poly = polygon.slice(0, polygon.length - 1);

      // If only one triangle remains, add it and clear the working polygon.
      if (poly.length === 3) {
        triangles.push([...poly]);
        polygon = [];
        draw();
        return;
      }

      let earIndex = -1;
      for (let i = 0; i < poly.length; i++) {
        if (isEar(i, [...poly, poly[0]])) {
          earIndex = i;
          break;
        }
      }

      if (earIndex === -1) {
        alert("No ear found. The drawn region may be self-intersecting or invalid.");
        return;
      }

      const prev = poly[(earIndex - 1 + poly.length) % poly.length];
      const curr = poly[earIndex];
      const next = poly[(earIndex + 1) % poly.length];
      triangles.push([prev, curr, next]);

      // Remove the ear vertex.
      poly.splice(earIndex, 1);
      // Rebuild the closed polygon.
      polygon = [...poly, poly[0]];
      draw({ prev, curr, next });
    }

    // Draw the current state.
    // If earTriangle is provided, highlight it with a red outline.
    function draw(earTriangle) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw completed triangles in green.
      triangles.forEach(tri => {
        ctx.beginPath();
        ctx.moveTo(tri[0].x, tri[0].y);
        ctx.lineTo(tri[1].x, tri[1].y);
        ctx.lineTo(tri[2].x, tri[2].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
        ctx.fill();
        ctx.strokeStyle = "green";
        ctx.stroke();
      });

      // Draw the current polygon in blue.
      if (polygon.length > 0) {
        ctx.beginPath();
        ctx.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i++) {
          ctx.lineTo(polygon[i].x, polygon[i].y);
        }
        ctx.strokeStyle = "blue";
        ctx.stroke();
      }

      // Draw the vertices as small black circles.
      polygon.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = "black";
        ctx.fill();
      });

      // Draw the snap zone indicator around the first point.
      if (originalPoints.length > 0) {
        ctx.beginPath();
        ctx.arc(originalPoints[0].x, originalPoints[0].y, snapThreshold, 0, Math.PI * 2);
        ctx.strokeStyle = "orange";
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // If an ear triangle is provided, highlight it in red.
      if (earTriangle) {
        ctx.beginPath();
        ctx.moveTo(earTriangle.prev.x, earTriangle.prev.y);
        ctx.lineTo(earTriangle.curr.x, earTriangle.curr.y);
        ctx.lineTo(earTriangle.next.x, earTriangle.next.y);
        ctx.closePath();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.lineWidth = 1;
      }
    }

    document.getElementById("nextStep").addEventListener("click", stepEarClipping);
    document.getElementById("clear").addEventListener("click", () => {
      originalPoints = [];
      polygon = [];
      triangles = [];
      drawing = false;
      isSnapped = false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });
  </script>
</body>
</html>
