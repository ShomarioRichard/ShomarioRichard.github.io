<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Earcut Animation with Step-by-Step Math Explanation</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    #container {
      display: flex;
      height: 100vh;
    }
    #left-panel {
      flex: 2;
      padding: 10px;
      box-sizing: border-box;
    }
    #right-panel {
      flex: 1;
      padding: 10px;
      background-color: #f4f4f4;
      border-left: 1px solid #ccc;
      box-sizing: border-box;
      overflow-y: auto;
    }
    canvas {
      border: 1px solid #ccc;
      margin-bottom: 10px;
      display: block;
    }
    #controls button {
      margin-right: 5px;
      margin-bottom: 5px;
    }
    h2, h3, h4 {
      margin-top: 0;
    }
    pre {
      background: #eee;
      padding: 8px;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="left-panel">
      <canvas id="canvas" width="600" height="400"></canvas>
      <div id="controls">
        <button id="clear">Clear</button>
        <button id="animate">Animate Triangulation</button>
      </div>
    </div>
    <div id="right-panel">
      <h2>Step-by-Step Math Explanation</h2>
      <div id="details">
        <p>
          Click on the canvas to define your polygon. When ready, click "Animate Triangulation" to see the ear clipping algorithm in action.
        </p>
        <h3>Overview</h3>
        <p>
          The algorithm iteratively removes "ears" from the polygon. At each step, it:
        </p>
        <ul>
          <li>Determines the polygon’s orientation (using signed area).</li>
          <li>Checks each vertex’s convexity via the cross product.</li>
          <li>Performs a point‑in‑triangle test for other vertices.</li>
          <li>If no other point lies within the candidate ear, it clips that ear.</li>
        </ul>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const detailsEl = document.getElementById("details");
    // Store vertices as objects: {x, y}
    let points = [];

    // Capture user clicks to define the polygon.
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      points.push({ x, y });
      drawAll(points, []);  // Redraw current polygon.
      updateDetails(`<p><strong>Added point:</strong> (${x.toFixed(0)}, ${y.toFixed(0)}). Total vertices: ${points.length}.</p>`);
    });

    // Append a message to the details panel.
    function updateDetails(message) {
      detailsEl.innerHTML += message;
      detailsEl.scrollTop = detailsEl.scrollHeight;
    }

    // Draw the current state: finalized triangles, current polygon, vertices, and optionally the highlighted ear.
    function drawAll(currentPoly, triangles, highlightEar = null) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw finalized triangles (filled in semi-transparent green).
      triangles.forEach(tri => {
        ctx.beginPath();
        ctx.moveTo(tri[0].x, tri[0].y);
        ctx.lineTo(tri[1].x, tri[1].y);
        ctx.lineTo(tri[2].x, tri[2].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(0, 128, 0, 0.3)";
        ctx.fill();
        ctx.strokeStyle = "green";
        ctx.stroke();
      });

      // Draw current polygon edges.
      if (currentPoly.length) {
        ctx.beginPath();
        ctx.moveTo(currentPoly[0].x, currentPoly[0].y);
        for (let i = 1; i < currentPoly.length; i++) {
          ctx.lineTo(currentPoly[i].x, currentPoly[i].y);
        }
        if (currentPoly.length > 2) ctx.closePath();
        ctx.strokeStyle = "#999";
        ctx.stroke();
      }

      // Draw vertices.
      currentPoly.forEach(pt => {
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = "black";
        ctx.fill();
      });

      // Highlight the current ear if provided.
      if (highlightEar) {
        ctx.beginPath();
        ctx.moveTo(highlightEar[0].x, highlightEar[0].y);
        ctx.lineTo(highlightEar[1].x, highlightEar[1].y);
        ctx.lineTo(highlightEar[2].x, highlightEar[2].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
        ctx.fill();
        ctx.strokeStyle = "red";
        ctx.stroke();
      }
    }

    // Compute the signed area to determine polygon orientation.
    function signedArea(poly) {
      let area = 0;
      for (let i = 0; i < poly.length; i++) {
        const j = (i + 1) % poly.length;
        area += poly[i].x * poly[j].y - poly[j].x * poly[i].y;
      }
      return area / 2;
    }

    // Check convexity of vertex B (with neighbors A and C) using the cross product.
    function isConvex(A, B, C, isCCW) {
      let cross = (B.x - A.x) * (C.y - B.y) - (B.y - A.y) * (C.x - B.x);
      return isCCW ? (cross > 0) : (cross < 0);
    }

    // Check if point P is inside triangle formed by V1, V2, V3.
    function pointInTriangle(P, V1, V2, V3) {
      function sign(p1, p2, p3) {
        return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
      }
      let d1 = sign(P, V1, V2);
      let d2 = sign(P, V2, V3);
      let d3 = sign(P, V3, V1);
      return ((d1 < 0 && d2 < 0 && d3 < 0) || (d1 > 0 && d2 > 0 && d3 > 0));
    }

    // Animate the ear-clipping triangulation with step-by-step math explanation.
    function earClippingAnimation() {
      if (points.length < 3) {
        alert("Please define a polygon with at least 3 points.");
        return;
      }
      // Clear previous explanations.
      detailsEl.innerHTML = "";
      updateDetails("<p><strong>Starting ear clipping process.</strong></p>");
      let poly = points.slice();
      let triangles = [];
      let area = signedArea(poly);
      let isCCW = area > 0;
      updateDetails(`<p>Polygon has ${poly.length} vertices with signed area = ${area.toFixed(2)}. This indicates a ${isCCW ? "counterclockwise" : "clockwise"} orientation.</p>`);

      // Helper functions to navigate the polygon.
      function nextIndex(i) { return (i + 1) % poly.length; }
      function prevIndex(i) { return (i - 1 + poly.length) % poly.length; }

      // Find an ear while providing detailed math for each candidate.
      function findEar() {
        for (let i = 0; i < poly.length; i++) {
          let prev = poly[prevIndex(i)];
          let curr = poly[i];
          let next = poly[nextIndex(i)];
          // Compute the cross product.
          let cross = (curr.x - prev.x) * (next.y - curr.y) - (curr.y - prev.y) * (next.x - curr.x);
          let convexMsg = `<p><strong>Vertex ${i} check:</strong> Using vertices (${prev.x.toFixed(0)}, ${prev.y.toFixed(0)}), (${curr.x.toFixed(0)}, ${curr.y.toFixed(0)}), (${next.x.toFixed(0)}, ${next.y.toFixed(0)}), the cross product is ${cross.toFixed(2)}. `;
          convexMsg += isCCW 
            ? (cross > 0 ? "Since polygon is CCW and cross > 0, the vertex is convex." : "Not convex, since we expect > 0 for CCW.")
            : (cross < 0 ? "Since polygon is CW and cross < 0, the vertex is convex." : "Not convex, since we expect < 0 for CW.");
          convexMsg += "</p>";
          updateDetails(convexMsg);
          if (!isConvex(prev, curr, next, isCCW)) continue;
          
          // Now check if any other vertex lies inside the triangle.
          let earValid = true;
          let earTestMsg = `<p><strong>Testing triangle:</strong> (${prev.x.toFixed(0)}, ${prev.y.toFixed(0)}), (${curr.x.toFixed(0)}, ${curr.y.toFixed(0)}), (${next.x.toFixed(0)}, ${next.y.toFixed(0)})</p>`;
          for (let j = 0; j < poly.length; j++) {
            if (j === i || j === prevIndex(i) || j === nextIndex(i)) continue;
            let testPt = poly[j];
            // Calculate the signs for the point-in-triangle test.
            let sign1 = (testPt.x - next.x) * (prev.y - next.y) - (prev.x - next.x) * (testPt.y - next.y);
            let sign2 = (testPt.x - prev.x) * (curr.y - prev.y) - (curr.x - prev.x) * (testPt.y - prev.y);
            let sign3 = (testPt.x - curr.x) * (next.y - curr.y) - (next.x - curr.x) * (testPt.y - curr.y);
            earTestMsg += `<p>For vertex ${j} at (${testPt.x.toFixed(0)}, ${testPt.y.toFixed(0)}): sign values are ${sign1.toFixed(2)}, ${sign2.toFixed(2)}, ${sign3.toFixed(2)}.</p>`;
            if ((sign1 < 0 && sign2 < 0 && sign3 < 0) || (sign1 > 0 && sign2 > 0 && sign3 > 0)) {
              earTestMsg += `<p>Vertex ${j} lies inside the triangle. This disqualifies the ear.</p>`;
              earValid = false;
              break;
            } else {
              earTestMsg += `<p>Vertex ${j} is not inside the triangle.</p>`;
            }
          }
          updateDetails(earTestMsg);
          if (earValid) {
            updateDetails(`<p><strong>Valid ear found</strong> at vertex ${i}. This ear will be clipped.</p>`);
            return { earIndex: i, ear: [prev, curr, next] };
          }
        }
        return null;
      }

      // Process one ear clipping step.
      function step() {
        if (poly.length <= 3) {
          if (poly.length === 3) {
            triangles.push(poly.slice());
            updateDetails(`<p>Final triangle formed with vertices: (${poly[0].x.toFixed(0)}, ${poly[0].y.toFixed(0)}), (${poly[1].x.toFixed(0)}, ${poly[1].y.toFixed(0)}), (${poly[2].x.toFixed(0)}, ${poly[2].y.toFixed(0)}).</p>`);
          }
          drawAll([], triangles);
          updateDetails("<p><strong>Triangulation complete!</strong></p>");
          return;
        }
        let earData = findEar();
        if (!earData) {
          updateDetails("<p>No valid ear found. The polygon might be non-simple.</p>");
          drawAll(poly, triangles);
          return;
        }
        let earIndex = earData.earIndex;
        let ear = earData.ear;
        // Highlight the ear.
        drawAll(poly, triangles, ear);
        updateDetails("<p>Highlighting the ear for 500ms before clipping it...</p>");
        setTimeout(() => {
          let removed = poly.splice(earIndex, 1)[0];
          triangles.push(ear);
          updateDetails(`<p>Clipped ear at vertex with coordinates (${removed.x.toFixed(0)}, ${removed.y.toFixed(0)}). Now ${poly.length} vertices remain.</p>`);
          drawAll(poly, triangles);
          setTimeout(step, 500);
        }, 500);
      }
      step();
    }

    document.getElementById("clear").addEventListener("click", () => {
      points = [];
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      detailsEl.innerHTML = "<p>Canvas cleared. Click on the canvas to add points.</p>";
    });

    document.getElementById("animate").addEventListener("click", () => {
      earClippingAnimation();
    });
  </script>
</body>
</html>
