<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Step-by-Step Earcut Visualization</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      margin-bottom: 10px;
    }
    #controls button {
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="600" height="400"></canvas>
  <div id="controls">
    <button id="clear">Clear</button>
    <button id="start">Start Triangulation</button>
    <button id="step" disabled>Next Step</button>
  </div>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    // Store user-defined points as objects {x, y}
    let points = [];
    // polygon will hold the working list of vertices for ear clipping
    let polygon = [];
    // triangles will accumulate the completed ear triangles
    let triangles = [];
    // currentEar holds the most recent ear candidate for visualization
    let currentEar = null;

    // Click on canvas to add vertices.
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      points.push({ x, y });
      draw();
    });

    // "Clear" resets everything.
    document.getElementById("clear").addEventListener("click", () => {
      points = [];
      polygon = [];
      triangles = [];
      currentEar = null;
      document.getElementById("step").disabled = true;
      draw();
    });

    // "Start Triangulation" copies the user points into the working polygon.
    document.getElementById("start").addEventListener("click", () => {
      if (points.length < 3) {
         alert("Please define at least 3 points.");
         return;
      }
      polygon = points.slice(); // make a copy
      triangles = [];
      currentEar = null;
      document.getElementById("step").disabled = false;
      draw();
    });

    // "Next Step" performs one ear clipping iteration.
    document.getElementById("step").addEventListener("click", () => {
      // If only three vertices remain, add the final triangle.
      if (polygon.length === 3) {
         triangles.push(polygon.slice());
         polygon = [];
         currentEar = null;
         draw();
         document.getElementById("step").disabled = true;
         return;
      }
      let earIndex = findEarIndex(polygon);
      if (earIndex === -1) {
         alert("No ear found! The polygon may be non-simple.");
         document.getElementById("step").disabled = true;
         return;
      }
      // Identify the ear triangle: previous, current (ear), and next vertices.
      const prevIndex = (earIndex - 1 + polygon.length) % polygon.length;
      const nextIndex = (earIndex + 1) % polygon.length;
      const earTriangle = [polygon[prevIndex], polygon[earIndex], polygon[nextIndex]];
      // Add the ear triangle to the list of completed triangles.
      triangles.push(earTriangle);
      // Remove the ear's vertex from the polygon.
      polygon.splice(earIndex, 1);
      // For visualization, store the current ear.
      currentEar = earTriangle;
      draw();
    });

    // Finds an index in the polygon that forms an ear.
    function findEarIndex(poly) {
      for (let i = 0; i < poly.length; i++) {
         const prev = poly[(i - 1 + poly.length) % poly.length];
         const curr = poly[i];
         const next = poly[(i + 1) % poly.length];
         if (!isConvex(prev, curr, next)) continue;
         let earFound = true;
         // Check that no other point lies inside the candidate ear.
         for (let j = 0; j < poly.length; j++) {
            // Skip the vertices of the ear triangle.
            if (j === (i - 1 + poly.length) % poly.length ||
                j === i ||
                j === (i + 1) % poly.length) continue;
            if (pointInTriangle(poly[j], prev, curr, next)) {
              earFound = false;
              break;
            }
         }
         if (earFound) {
           return i;
         }
      }
      return -1;
    }

    // Determines if the angle at vertex b (with neighbors a and c) is convex.
    // Note: For a polygon defined in clockwise order, a convex angle will have a negative cross product.
    function isConvex(a, b, c) {
       const crossProd = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
       return crossProd < 0;
    }

    // Checks if point p lies inside triangle abc using the barycentric technique.
    function pointInTriangle(p, a, b, c) {
      const area  = Math.abs(cross(a, b, c));
      const area1 = Math.abs(cross(p, b, c));
      const area2 = Math.abs(cross(a, p, c));
      const area3 = Math.abs(cross(a, b, p));
      return Math.abs(area - (area1 + area2 + area3)) < 0.01;
    }

    // Helper function to compute the cross product (area) for three points.
    function cross(p, q, r) {
      return (q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x);
    }

    // Draws the current state: completed triangles, remaining polygon, and the current ear candidate.
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw completed triangles (filled with light blue).
      for (const tri of triangles) {
         ctx.beginPath();
         ctx.moveTo(tri[0].x, tri[0].y);
         ctx.lineTo(tri[1].x, tri[1].y);
         ctx.lineTo(tri[2].x, tri[2].y);
         ctx.closePath();
         ctx.fillStyle = "rgba(173,216,230,0.5)";
         ctx.fill();
         ctx.strokeStyle = "blue";
         ctx.stroke();
      }
      
      // Draw the current working polygon (its outline in black).
      if (polygon.length > 0) {
         ctx.beginPath();
         ctx.moveTo(polygon[0].x, polygon[0].y);
         for (let i = 1; i < polygon.length; i++) {
            ctx.lineTo(polygon[i].x, polygon[i].y);
         }
         ctx.closePath();
         ctx.strokeStyle = "black";
         ctx.stroke();
      }
      
      // If an ear candidate was just removed, highlight it in red.
      if (currentEar) {
         ctx.beginPath();
         ctx.moveTo(currentEar[0].x, currentEar[0].y);
         ctx.lineTo(currentEar[1].x, currentEar[1].y);
         ctx.lineTo(currentEar[2].x, currentEar[2].y);
         ctx.closePath();
         ctx.strokeStyle = "red";
         ctx.lineWidth = 2;
         ctx.stroke();
         ctx.lineWidth = 1;
      }
      
      // Optionally, draw all original points if the polygon hasn't started.
      if (points.length > 0 && polygon.length === 0) {
         for (const p of points) {
           ctx.beginPath();
           ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
           ctx.fillStyle = "black";
           ctx.fill();
         }
      }
    }
  </script>
</body>
</html>
