<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Earcut Animation Visualization</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      margin-bottom: 10px;
    }
    #controls button {
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="600" height="400"></canvas>
  <div id="controls">
    <button id="clear">Clear</button>
    <button id="animate">Animate Triangulation</button>
  </div>
  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    // Store vertices as objects: {x, y}
    let points = [];

    // Capture user clicks to define the polygon.
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      points.push({ x, y });
      drawAll(points, []);  // draw current polygon
    });

    // Draw the complete scene:
    // - current polygon (not yet clipped)
    // - finalized triangles
    // - an optional highlighted ear (in red)
    function drawAll(currentPoly, triangles, highlightEar = null) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw finalized triangles (filled green)
      triangles.forEach(tri => {
        ctx.beginPath();
        ctx.moveTo(tri[0].x, tri[0].y);
        ctx.lineTo(tri[1].x, tri[1].y);
        ctx.lineTo(tri[2].x, tri[2].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(0, 128, 0, 0.3)"; // semi-transparent green
        ctx.fill();
        ctx.strokeStyle = "green";
        ctx.stroke();
      });

      // Draw current polygon edges
      if (currentPoly.length) {
        ctx.beginPath();
        ctx.moveTo(currentPoly[0].x, currentPoly[0].y);
        for (let i = 1; i < currentPoly.length; i++) {
          ctx.lineTo(currentPoly[i].x, currentPoly[i].y);
        }
        if (currentPoly.length > 2) {
          ctx.closePath();
        }
        ctx.strokeStyle = "#999";
        ctx.stroke();
      }

      // Draw vertices as black circles.
      currentPoly.forEach(pt => {
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = "black";
        ctx.fill();
      });

      // If provided, highlight the current ear in semi-transparent red.
      if (highlightEar) {
        ctx.beginPath();
        ctx.moveTo(highlightEar[0].x, highlightEar[0].y);
        ctx.lineTo(highlightEar[1].x, highlightEar[1].y);
        ctx.lineTo(highlightEar[2].x, highlightEar[2].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
        ctx.fill();
        ctx.strokeStyle = "red";
        ctx.stroke();
      }
    }

    // Helper: compute signed area to determine polygon orientation.
    function signedArea(poly) {
      let area = 0;
      for (let i = 0; i < poly.length; i++) {
        const j = (i + 1) % poly.length;
        area += poly[i].x * poly[j].y - poly[j].x * poly[i].y;
      }
      return area / 2;
    }

    // Helper: check if vertex b (with neighbors a and c) is convex.
    function isConvex(a, b, c, isCCW) {
      // Cross product of vectors (b - a) and (c - b)
      let cross = (b.x - a.x) * (c.y - b.y) - (b.y - a.y) * (c.x - b.x);
      return isCCW ? (cross > 0) : (cross < 0);
    }

    // Helper: check if point pt is inside triangle (v1, v2, v3).
    function pointInTriangle(pt, v1, v2, v3) {
      function sign(p1, p2, p3) {
        return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
      }
      let b1 = sign(pt, v1, v2) < 0;
      let b2 = sign(pt, v2, v3) < 0;
      let b3 = sign(pt, v3, v1) < 0;
      return (b1 === b2) && (b2 === b3);
    }

    // Animate the ear-clipping (triangulation) process.
    function earClippingAnimation() {
      if (points.length < 3) {
        alert("Please define a polygon with at least 3 points.");
        return;
      }
      // Make a working copy of the polygon.
      let poly = points.slice();
      let triangles = [];
      let isCCW = signedArea(poly) > 0;

      // Helper functions to get neighbor indices.
      function nextIndex(i) { return (i + 1) % poly.length; }
      function prevIndex(i) { return (i - 1 + poly.length) % poly.length; }

      // Find the first "ear" in the current polygon.
      function findEar() {
        for (let i = 0; i < poly.length; i++) {
          let prev = poly[prevIndex(i)];
          let curr = poly[i];
          let next = poly[nextIndex(i)];
          if (!isConvex(prev, curr, next, isCCW)) continue;
          // Ensure no other vertex is inside the triangle.
          let earFound = true;
          for (let j = 0; j < poly.length; j++) {
            if (j === i || j === prevIndex(i) || j === nextIndex(i)) continue;
            if (pointInTriangle(poly[j], prev, curr, next)) {
              earFound = false;
              break;
            }
          }
          if (earFound) {
            return { earIndex: i, ear: [prev, curr, next] };
          }
        }
        return null;
      }

      // Process one ear-clipping step.
      function step() {
        if (poly.length <= 3) {
          // Last remaining triangle.
          if (poly.length === 3) {
            triangles.push(poly.slice());
          }
          drawAll([], triangles);
          return;
        }
        let earData = findEar();
        if (!earData) {
          console.log("No ear found. The polygon may be non-simple.");
          drawAll(poly, triangles);
          return;
        }
        let earIndex = earData.earIndex;
        let ear = earData.ear;
        // Highlight the ear.
        drawAll(poly, triangles, ear);
        // Pause to show the highlighted ear, then clip it.
        setTimeout(() => {
          // Remove the ear's vertex (the middle one).
          poly.splice(earIndex, 1);
          // Save the ear as a finalized triangle.
          triangles.push(ear);
          // Redraw the scene and continue after a brief delay.
          drawAll(poly, triangles);
          setTimeout(step, 500);
        }, 500);
      }
      step();
    }

    document.getElementById("clear").addEventListener("click", () => {
      points = [];
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    document.getElementById("animate").addEventListener("click", () => {
      earClippingAnimation();
    });
  </script>
</body>
</html>
