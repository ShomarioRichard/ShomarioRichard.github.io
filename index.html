<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Cipher vs. Tracker: Game-Theoretic Privacy Battle</title>
  <style>
    /* Ensure the page and canvas fill the whole window */
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      width: 100%;
      background: rgb(10, 10, 10);
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    // Setup canvas and context
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    
    // Dynamically set canvas dimensions to fill the window
    let WIDTH = window.innerWidth;
    let HEIGHT = window.innerHeight;
    canvas.width = WIDTH;
    canvas.height = HEIGHT;

    // Update canvas size on window resize
    window.addEventListener("resize", () => {
      WIDTH = window.innerWidth;
      HEIGHT = window.innerHeight;
      canvas.width = WIDTH;
      canvas.height = HEIGHT;
    });

    // Colors (using CSS rgb strings)
    const BLACK      = "rgb(10, 10, 10)";
    const WHITE      = "rgb(255, 255, 255)";
    const CYBER_BLUE = "rgb(50, 130, 255)";
    const CYBER_GREEN= "rgb(50, 255, 130)";
    const RED        = "rgb(200, 50, 50)";
    const YELLOW     = "rgb(255, 200, 50)";
    const GRAY       = "rgb(100, 100, 100)";

    // Fonts
    const FONT = "28px Arial";
    const BIG_FONT = "36px Arial";

    // ------------------
    // Global Game States
    // ------------------
    // State machine: roleSelection, textCrawl, gamePlaying, gameOverScreen
    let state = "roleSelection";

    // Game variables
    let roundNumber = 1;
    const totalRounds = 5;
    let playerRole = null;
    let aiRole = null;
    let roundSummary = "";
    let gameOver = false;
    let waitingForNextRound = false;

    // Cipher variables
    let cipherCost = 0;
    let cipherDataTransferred = 0;
    const cipherCostLimit = 30;
    const cipherDataTarget = 40;

    // Tracker variables
    let trackerIdentificationRisk = 0;
    let trackerDataIntercepted = 0;
    const trackerInterceptionTarget = 20;
    const trackerIdentificationLimit = 15;

    // Choices for each role
    const cipherChoices = {
      "Low Encryption":    { cost: 2, data: 10, security: 1 },
      "Medium Encryption": { cost: 5, data: 7,  security: 2 },
      "High Encryption":   { cost: 8, data: 4,  security: 3 }
    };

    const trackerChoices = {
      "Minimum Attack": { interception: 30, risk: 1 },
      "Medium Attack":  { interception: 50, risk: 3 },
      "Maximum Attack": { interception: 80, risk: 5 }
    };

    // Variables to hold the current round’s choices
    let cipherChoice = null;
    let trackerChoice = null;

    // For the typewriter effect on the game‑over screen
    let completedLines = [];
    let gameOverReason = [];

    // ------------------
    // Mouse Events
    // ------------------
    let mouseX = 0;
    let mouseY = 0;
    canvas.addEventListener("mousemove", (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = e.clientX - rect.left;
      mouseY = e.clientY - rect.top;
    });

    // ------------------
    // Button Class
    // ------------------
    class Button {
      constructor(x, y, width, height, text, color, hoverColor) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.text = text;
        this.color = color;
        this.hoverColor = hoverColor;
      }
      draw(ctx) {
        // Check if mouse is over this button
        const isHover = (mouseX >= this.x && mouseX <= this.x + this.width &&
                         mouseY >= this.y && mouseY <= this.y + this.height);
        ctx.fillStyle = isHover ? this.hoverColor : this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        // Draw centered text
        ctx.font = FONT;
        ctx.fillStyle = WHITE;
        const textWidth = ctx.measureText(this.text).width;
        ctx.fillText(this.text, this.x + (this.width - textWidth) / 2, this.y + this.height/2 + 10);
      }
      isClicked(x, y) {
        return (x >= this.x && x <= this.x + this.width &&
                y >= this.y && y <= this.y + this.height);
      }
    }

    // ------------------------------
    // Role Selection Buttons
    // ------------------------------
    // (Positions may shift as the canvas is now full screen.)
    const cipherButton = new Button(WIDTH * 0.28, HEIGHT * 0.4, 200, 50, "Play as Cipher", CYBER_GREEN, CYBER_BLUE);
    const trackerButton = new Button(WIDTH * 0.55, HEIGHT * 0.4, 200, 50, "Play as Tracker", RED, GRAY);

    // Decision buttons for game rounds
    // Move decision buttons up by reducing the y-coordinate (from 0.43 to 0.38 of HEIGHT)
    const cipherButtons = [
      new Button(WIDTH * 0.06, HEIGHT * 0.38, 200, 50, "Low Encryption", RED, CYBER_BLUE),
      new Button(WIDTH * 0.45, HEIGHT * 0.38, 200, 50, "Medium Encryption", RED, CYBER_BLUE),
      new Button(WIDTH * 0.60, HEIGHT * 0.38, 200, 50, "High Encryption", RED, CYBER_BLUE)
    ];

    const trackerButtons = [
      new Button(WIDTH * 0.17, HEIGHT * 0.38, 200, 50, "Minimum Attack", RED, GRAY),
      new Button(WIDTH * 0.41, HEIGHT * 0.38, 200, 50, "Medium Attack", RED, GRAY),
      new Button(WIDTH * 0.68, HEIGHT * 0.38, 200, 50, "Maximum Attack", RED, GRAY)
    ];


    // ------------------------------
    // Text Crawl Variables & Logic
    // ------------------------------
    const crawlText = [
      "Year 2084: The world is shackled in a grip of data-driven tyranny.",
      "Megacorporations rule without question, their surveillance absolute.",
      "Every transaction, whisper, and fleeting thought is recorded,",
      "analyzed, controlled, and weaponized against the powerless.",
      "",
      "Cipher: A corporate enforcer, bound by contract and control.",
      "Encrypt. Conceal. Execute. The system rewards loyalty and obedience.",
      "",
      "Tracker: A rogue hacker, fighting to expose the truth.",
      "Intercept. Extract. Eradicate. The walls of secrecy must collapse.",
      "",
      "The war is fought in shadows—a battle of whispers and firewalls.",
      "Every move carries risk. Every transmission could be the last.",
      "The megacorp is watching. The noose tightens with each cycle.",
      "",
      "There is no escape. There is only the game.",
      "",
      "Press any key to begin..."
    ];
    let crawlYPosition = HEIGHT;  // start off‐screen
    const crawlSpeed = 2;
    let crawlFinished = false;

    // Allow keypress to skip the text crawl
    document.addEventListener("keydown", (e) => {
      if (state === "textCrawl") {
        crawlFinished = true;
      }
    });

    // ------------------------------
    // Mouse Clicks (for Buttons)
    // ------------------------------
    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;

      if (state === "roleSelection") {
        if (cipherButton.isClicked(clickX, clickY)) {
          playerRole = "Cipher";
          aiRole = "Tracker";
          state = "textCrawl";
          console.log("[DEBUG] Player selected Cipher");
        } else if (trackerButton.isClicked(clickX, clickY)) {
          playerRole = "Tracker";
          aiRole = "Cipher";
          state = "textCrawl";
          console.log("[DEBUG] Player selected Tracker");
        }
      }
      else if (state === "gamePlaying") {
        if (!gameOver && !waitingForNextRound) {
          if (playerRole === "Cipher" && cipherChoice === null) {
            // Check which cipher button was clicked
            for (let i = 0; i < cipherButtons.length; i++) {
              if (cipherButtons[i].isClicked(clickX, clickY)) {
                cipherChoice = Object.keys(cipherChoices)[i];
                // AI makes its decision for Tracker
                trackerChoice = aiTrackerDecision();
                console.log("[DEBUG] Cipher choice: " + cipherChoice + ", Tracker AI choice: " + trackerChoice);
                processRound();
              }
            }
          }
          else if (playerRole === "Tracker") {
            // For Tracker, have AI choose Cipher if not already chosen
            if (cipherChoice === null) {
              cipherChoice = aiCipherDecision();
              console.log("[DEBUG] AI Cipher choice: " + cipherChoice);
            }
            if (trackerChoice === null) {
              for (let i = 0; i < trackerButtons.length; i++) {
                if (trackerButtons[i].isClicked(clickX, clickY)) {
                  trackerChoice = Object.keys(trackerChoices)[i];
                  console.log("[DEBUG] Tracker choice: " + trackerChoice);
                  processRound();
                }
              }
            }
          }
        }
      }
    });

    // ------------------------------
    // AI Decision Functions
    // ------------------------------
    function aiTrackerDecision() {
      const keys = Object.keys(trackerChoices);
      return keys[Math.floor(Math.random() * keys.length)];
    }
    function aiCipherDecision() {
      const keys = Object.keys(cipherChoices);
      return keys[Math.floor(Math.random() * keys.length)];
    }

    // ------------------------------
    // Process a Game Round
    // ------------------------------
    function processRound() {
      if (cipherChoice && trackerChoice) {
        // Update Cipher stats
        cipherDataTransferred += cipherChoices[cipherChoice].data;
        cipherCost += cipherChoices[cipherChoice].cost;

        // Update Tracker stats
        const interceptedData = Math.floor((cipherChoices[cipherChoice].data * trackerChoices[trackerChoice].interception) / 100);
        trackerDataIntercepted += interceptedData;
        trackerIdentificationRisk += trackerChoices[trackerChoice].risk;

        roundSummary = `Cipher: ${cipherChoice} | Tracker: ${trackerChoice} | Data Sent: ${cipherChoices[cipherChoice].data} | Data Intercepted: ${interceptedData}`;
        waitingForNextRound = true;

        // Delay briefly then increment the round and check for game-over conditions
        setTimeout(() => {
          roundNumber++;
          checkGameOverConditions();
          if (!gameOver) {
            // Reset for next round
            cipherChoice = null;
            trackerChoice = null;
            waitingForNextRound = false;
          }
        }, 1000);
      }
    }

    // ------------------------------
    // Check Game Over Conditions
    // ------------------------------
    function checkGameOverConditions() {
      if (cipherDataTransferred >= cipherDataTarget && cipherCost <= cipherCostLimit) {
        roundSummary = "Cipher Triumphs! The firewall holds.";
        gameOverReason = [
          "Cipher successfully encrypted and transmitted the data.",
          "The megacorp’s secrets remain locked away in its fortress.",
          "For now, the machine continues grinding, unquestioned, unchallenged."
        ];
        gameOver = true;
        state = "gameOverScreen";
      }
      else if (trackerDataIntercepted >= trackerInterceptionTarget && trackerIdentificationRisk < trackerIdentificationLimit) {
        roundSummary = "Tracker Wins! The truth escapes… for now.";
        gameOverReason = [
          "The intercepted data leaks to the underground network.",
          "The people glimpse the truth before the megacorp clamps down.",
          "New encryption protocols go live. The cycle continues."
        ];
        gameOver = true;
        state = "gameOverScreen";
      }
      else if (cipherCost > cipherCostLimit) {
        roundSummary = "Game Over! Cipher is financially liquidated.";
        gameOverReason = [
          "Cipher’s reckless spending has exceeded budget.",
          "The megacorp does not tolerate inefficiency.",
          "Debts are forcibly collected. Identity revoked.",
          "Assigned a serial number, they serve as a digital slave.",
          "Their mind, uploaded into a corporate mainframe, encrypts data forever."
        ];
        gameOver = true;
        state = "gameOverScreen";
      }
      else if (trackerIdentificationRisk >= trackerIdentificationLimit) {
        roundSummary = "Game Over! Tracker has been terminated.";
        gameOverReason = [
          "Tracker’s aggressive hacking triggered too many security alarms.",
          "Synthetic enforcers breach their hideout in minutes.",
          "The last thing they see is a corporate logo on a neural disruptor.",
          "Their mind is extracted, rewritten, and turned into an AI slave.",
          "They now hunt the very kind of dissent they once fought for."
        ];
        gameOver = true;
        state = "gameOverScreen";
      }
      else if (roundNumber > totalRounds && !gameOver) {
        roundSummary = "Game Over! The war grinds on.";
        gameOverReason = [
          "Neither Cipher nor Tracker achieved their goal in time.",
          "The megacorp remains unshaken, its surveillance expanding.",
          "The resistance fractures, splinters, fades into whispers in the dark.",
          "The war was never meant to be won."
        ];
        gameOver = true;
        state = "gameOverScreen";
      }
    }

    // ------------------------------
    // Draw the Payoff Matrix
    // ------------------------------
    function drawPayoffMatrix() {
      // Adjust the matrix's starting position, row height, and column width
      const matrixX = WIDTH * 0.20;
      const matrixY = HEIGHT * 0.55;
      const rowHeight = 70;  // vertical spacing per row
      const colWidth = 250;  // horizontal spacing per column

      ctx.font = FONT;
      ctx.fillStyle = WHITE;
      // Draw header label for the matrix
      ctx.fillText("Cipher / Tracker", matrixX - 140, matrixY - 40);

      // Draw column headers for Tracker choices
      const trackerKeys = Object.keys(trackerChoices);
      for (let j = 0; j < trackerKeys.length; j++) {
        ctx.fillText(trackerKeys[j], matrixX + j * colWidth + 50, matrixY);
      }

      // Draw rows for Cipher choices and their payoff details
      const cipherKeys = Object.keys(cipherChoices);
      for (let i = 0; i < cipherKeys.length; i++) {
        // Move the encryption choice labels further to the left (changed from -210 to -240)
        ctx.fillText(cipherKeys[i], matrixX - 240, matrixY + (i + 1) * rowHeight);
        for (let j = 0; j < trackerKeys.length; j++) {
          const cipherData = cipherChoices[cipherKeys[i]].data;
          const cipherCostVal = cipherChoices[cipherKeys[i]].cost;
          const trackerInterception = Math.floor((cipherData * trackerChoices[trackerKeys[j]].interception) / 100);
          const trackerRisk = trackerChoices[trackerKeys[j]].risk;
          const payoffText = `(${cipherData}D, ${cipherCostVal}C) | (${trackerInterception}I, ${trackerRisk}R)`;
          ctx.fillText(payoffText, matrixX + j * colWidth + 20, matrixY + (i + 1) * rowHeight);
        }
      }

      // Draw the legend below the matrix
      const legendY = matrixY + (cipherKeys.length + 1) * rowHeight + 10;
      ctx.fillStyle = CYBER_BLUE;
      ctx.fillText("Legend:", matrixX, legendY);
      ctx.fillStyle = WHITE;
      ctx.fillText("D = Data Sent (Cipher), C = Cost (Cipher)", matrixX, legendY + 25);
      ctx.fillText("I = Data Intercepted (Tracker), R = Identification Risk (Tracker)", matrixX, legendY + 50);
    }




    // ------------------------------
    // Typewriter Effect for Game Over Screen
    // ------------------------------
    function typewriterEffect(text, x, y, color, delay, callback) {
      let displayedText = "";
      let i = 0;
      function type() {
        if (i < text.length) {
          displayedText += text[i];
          i++;
          drawGameOverScreen(); // redraw updated game-over screen
          setTimeout(type, delay);
        } else {
          completedLines.push(displayedText);
          if (callback) callback();
        }
      }
      type();
    }

    // Draw the Game Over screen (called repeatedly during the typewriter effect)
    function drawGameOverScreen() {
      ctx.fillStyle = BLACK;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      // "GAME OVER" heading
      ctx.font = BIG_FONT;
      ctx.fillStyle = CYBER_BLUE;
      const gameOverText = "GAME OVER";
      const gameOverTextWidth = ctx.measureText(gameOverText).width;
      ctx.fillText(gameOverText, (WIDTH - gameOverTextWidth) / 2, 100);

      // Display completed lines from typewriter effect
      ctx.font = FONT;
      ctx.fillStyle = WHITE;
      let yOffset = 200;
      for (let line of completedLines) {
        ctx.fillText(line, WIDTH/2 - 300, yOffset);
        yOffset += 40;
      }
      // Also display the round summary (if not yet fully typed)
      ctx.fillText(roundSummary, WIDTH/2 - ctx.measureText(roundSummary).width / 2, yOffset);

      // Final stats (displayed instantly)
      ctx.fillText(`Cipher Data Sent: ${cipherDataTransferred}/${cipherDataTarget}`, WIDTH/2 - 300, HEIGHT/2 + 80);
      ctx.fillText(`Cipher Cost: ${cipherCost}/${cipherCostLimit}`, WIDTH/2 - 300, HEIGHT/2 + 110);
      ctx.fillText(`Tracker Data Intercepted: ${trackerDataIntercepted}/${trackerInterceptionTarget}`, WIDTH/2 - 300, HEIGHT/2 + 140);
      ctx.fillText(`Tracker Identification Risk: ${trackerIdentificationRisk}/${trackerIdentificationLimit}`, WIDTH/2 - 300, HEIGHT/2 + 170);
    }

    // Start the typewriter effect (chain the round summary and game-over reason lines)
    function showGameOverScreen() {
      completedLines = []; // reset
      const textX = WIDTH/2 - 300;
      typewriterEffect(roundSummary, textX, 200, CYBER_BLUE, 50, () => {
        let yOffset = 250;
        let i = 0;
        function typeNextLine() {
          if (i < gameOverReason.length) {
            typewriterEffect(gameOverReason[i], textX, yOffset, WHITE, 40, () => {
              yOffset += 40;
              i++;
              typeNextLine();
            });
          }
        }
        typeNextLine();
      });
    }

    // ------------------------------
    // Main Update and Draw Functions
    // ------------------------------
    function update() {
      if (state === "textCrawl") {
        crawlYPosition -= crawlSpeed;
        // When the last line scrolls off or the user skipped:
        if (crawlYPosition + crawlText.length * 40 < -40 || crawlFinished) {
          state = "gamePlaying";
        }
      }
    }

    function draw() {
      // Clear the canvas
      ctx.fillStyle = BLACK;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);

      if (state === "roleSelection") {
        ctx.font = FONT;
        ctx.fillStyle = WHITE;
        ctx.fillText("Choose Your Role", WIDTH * 0.39, HEIGHT * 0.3);
        cipherButton.draw(ctx);
        trackerButton.draw(ctx);
      }
      else if (state === "textCrawl") {
        ctx.font = BIG_FONT;
        ctx.fillStyle = CYBER_BLUE;
        for (let i = 0; i < crawlText.length; i++) {
          const textWidth = ctx.measureText(crawlText[i]).width;
          ctx.fillText(crawlText[i], WIDTH/2 - textWidth/2, crawlYPosition + i * 40);
        }
      }
      else if (state === "gamePlaying") {
        // Draw the payoff matrix
        drawPayoffMatrix();

        // Display game stats
        ctx.font = FONT;
        ctx.fillStyle = WHITE;
        ctx.fillText(`Round ${roundNumber}/${totalRounds}`, 30, 30);
        ctx.fillStyle = CYBER_GREEN;
        ctx.fillText(`Cipher Data Sent: ${cipherDataTransferred}/${cipherDataTarget}`, 30, 70);
        ctx.fillStyle = CYBER_BLUE;
        ctx.fillText(`Cipher Cost: ${cipherCost}/${cipherCostLimit}`, 30, 100);
        ctx.fillStyle = RED;
        ctx.fillText(`Tracker Data Intercepted: ${trackerDataIntercepted}/${trackerInterceptionTarget}`, 30, 140);
        ctx.fillStyle = YELLOW;
        ctx.fillText(`Tracker Identification Risk: ${trackerIdentificationRisk}/${trackerIdentificationLimit}`, 30, 170);

        // Display round summary (centered)
        ctx.fillStyle = WHITE;
        const summaryWidth = ctx.measureText(roundSummary).width;
        ctx.fillText(roundSummary, (WIDTH - summaryWidth) / 2, 200);

        // Draw decision buttons depending on the player's role
        if (playerRole === "Cipher") {
          cipherButtons.forEach(btn => btn.draw(ctx));
        }
        else if (playerRole === "Tracker") {
          trackerButtons.forEach(btn => btn.draw(ctx));
        }
      }
      else if (state === "gameOverScreen") {
        drawGameOverScreen();
      }
    }

    function mainLoop() {
      update();
      draw();
      requestAnimationFrame(mainLoop);
    }
    mainLoop();
  </script>
</body>
</html>
