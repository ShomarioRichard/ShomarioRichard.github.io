<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Freehand Draw and Ear Clipping Visualization</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      margin-bottom: 10px;
      cursor: crosshair;
    }
    #controls button {
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="600" height="400"></canvas>
  <div id="controls">
    <button id="clear">Clear</button>
    <button id="finishDrawing">Finish Drawing</button>
    <button id="nextStep">Next Step</button>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    let drawing = false;
    let originalPoints = []; // All freehand-drawn points
    let polygon = [];        // The current polygon (will be closed)
    let triangles = [];      // Completed triangles from ear clipping

    // Start freehand drawing on mousedown.
    canvas.addEventListener("mousedown", (e) => {
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      originalPoints = [{ x, y }];
      polygon = [{ x, y }];
      draw();
    });

    // Capture mouse movements while drawing.
    canvas.addEventListener("mousemove", (e) => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      originalPoints.push({ x, y });
      polygon.push({ x, y });
      draw();
    });

    // End freehand drawing on mouseup.
    canvas.addEventListener("mouseup", () => {
      drawing = false;
      // Automatically close the polygon.
      if (polygon.length > 2) {
        polygon.push(polygon[0]);
      }
      draw();
    });

    // Option to explicitly finish drawing.
    document.getElementById("finishDrawing").addEventListener("click", () => {
      if (polygon.length > 2 &&
         (polygon[0].x !== polygon[polygon.length - 1].x ||
          polygon[0].y !== polygon[polygon.length - 1].y)) {
        polygon.push(polygon[0]);
      }
      draw();
    });

    // Geometry helper: Compute signed area of triangle (p, q, r)
    function area(p, q, r) {
      return (q.x - p.x) * (r.y - p.y) - (r.x - p.x) * (q.y - p.y);
    }

    // Check if the angle at 'curr' is convex.
    function isConvex(prev, curr, next) {
      return area(prev, curr, next) < 0;
    }

    // Check if point pt is inside triangle (v1, v2, v3)
    function isPointInTriangle(pt, v1, v2, v3) {
      const d1 = area(pt, v1, v2);
      const d2 = area(pt, v2, v3);
      const d3 = area(pt, v3, v1);
      const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
      const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);
      return !(hasNeg && hasPos);
    }

    // Determine if vertex at index i is an ear in the polygon.
    // Note: The polygon is expected to be closed (first point repeated at the end).
    function isEar(i, poly) {
      // Work with unique vertices (exclude duplicate last point).
      if (poly.length < 4) return false;
      const uniquePoly = poly.slice(0, poly.length - 1);
      const len = uniquePoly.length;
      const idx = i;
      const prev = uniquePoly[(idx - 1 + len) % len];
      const curr = uniquePoly[idx];
      const next = uniquePoly[(idx + 1) % len];

      if (!isConvex(prev, curr, next)) return false;

      // Ensure no other point is inside the candidate ear triangle.
      for (let j = 0; j < len; j++) {
        if (j === ((idx - 1 + len) % len) || j === idx || j === ((idx + 1) % len)) continue;
        if (isPointInTriangle(uniquePoly[j], prev, curr, next)) {
          return false;
        }
      }
      return true;
    }

    // Execute one ear clipping step.
    function stepEarClipping() {
      // Make sure we have a closed polygon.
      if (polygon.length < 4) {
        alert("Not enough points to triangulate.");
        return;
      }
      // Work with unique vertices (exclude duplicate last point).
      let poly = polygon.slice(0, polygon.length - 1);

      // If only one triangle remains, add it and clear the working polygon.
      if (poly.length === 3) {
        triangles.push([...poly]);
        polygon = [];
        draw();
        return;
      }

      let earIndex = -1;
      for (let i = 0; i < poly.length; i++) {
        if (isEar(i, [...poly, poly[0]])) {
          earIndex = i;
          break;
        }
      }

      if (earIndex === -1) {
        alert("No ear found. The drawn region may be self-intersecting or invalid.");
        return;
      }

      const prev = poly[(earIndex - 1 + poly.length) % poly.length];
      const curr = poly[earIndex];
      const next = poly[(earIndex + 1) % poly.length];
      triangles.push([prev, curr, next]);

      // Remove the ear vertex.
      poly.splice(earIndex, 1);
      // Rebuild the closed polygon.
      polygon = [...poly, poly[0]];
      draw({ prev, curr, next });
    }

    // Draw the current state: completed triangles, polygon outline, and optionally a highlighted ear.
    function draw(earTriangle) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw completed triangles in green.
      triangles.forEach(tri => {
        ctx.beginPath();
        ctx.moveTo(tri[0].x, tri[0].y);
        ctx.lineTo(tri[1].x, tri[1].y);
        ctx.lineTo(tri[2].x, tri[2].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
        ctx.fill();
        ctx.strokeStyle = "green";
        ctx.stroke();
      });

      // Draw the current polygon in blue.
      if (polygon.length > 0) {
        ctx.beginPath();
        ctx.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i++) {
          ctx.lineTo(polygon[i].x, polygon[i].y);
        }
        ctx.strokeStyle = "blue";
        ctx.stroke();
      }

      // Draw vertices.
      polygon.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = "black";
        ctx.fill();
      });

      // If an ear triangle is provided, highlight it in red.
      if (earTriangle) {
        ctx.beginPath();
        ctx.moveTo(earTriangle.prev.x, earTriangle.prev.y);
        ctx.lineTo(earTriangle.curr.x, earTriangle.curr.y);
        ctx.lineTo(earTriangle.next.x, earTriangle.next.y);
        ctx.closePath();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.lineWidth = 1;
      }
    }

    document.getElementById("nextStep").addEventListener("click", stepEarClipping);
    document.getElementById("clear").addEventListener("click", () => {
      originalPoints = [];
      polygon = [];
      triangles = [];
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });
  </script>
</body>
</html>
