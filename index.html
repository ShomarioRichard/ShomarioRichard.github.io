<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Step-by-Step Ear Clipping Visualization</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      margin-bottom: 10px;
    }
    #controls button {
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="600" height="400"></canvas>
  <div id="controls">
    <button id="clear">Clear</button>
    <button id="nextStep">Next Step</button>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    
    // Store vertices as objects with x and y
    let originalPoints = []; // All user-defined points
    let polygon = [];        // Working copy of the polygon vertices
    let triangles = [];      // Completed triangles

    // Capture user clicks to define the polygon
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const point = { x, y };
      originalPoints.push(point);
      polygon.push(point);
      draw();
    });

    // Clear the canvas and reset data.
    document.getElementById("clear").addEventListener("click", () => {
      originalPoints = [];
      polygon = [];
      triangles = [];
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    // Geometry helper: Compute signed area of triangle (p, q, r)
    function area(p, q, r) {
      return (q.x - p.x) * (r.y - p.y) - (r.x - p.x) * (q.y - p.y);
    }
    
    // Check if the angle at 'curr' is convex. (Assumes polygon vertices are in clockwise order.)
    function isConvex(prev, curr, next) {
      return area(prev, curr, next) < 0;
    }
    
    // Check if point pt is inside the triangle (v1, v2, v3)
    function isPointInTriangle(pt, v1, v2, v3) {
      const d1 = area(pt, v1, v2);
      const d2 = area(pt, v2, v3);
      const d3 = area(pt, v3, v1);
      const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
      const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);
      return !(hasNeg && hasPos);
    }
    
    // Determine if the vertex at index i forms an ear
    function isEar(i, poly) {
      if (poly.length < 3) return false;
      const prev = poly[(i - 1 + poly.length) % poly.length];
      const curr = poly[i];
      const next = poly[(i + 1) % poly.length];
      
      // The triangle must be convex.
      if (!isConvex(prev, curr, next)) return false;
      
      // No other vertex should lie inside the triangle.
      for (let j = 0; j < poly.length; j++) {
        // Skip the vertices of the triangle
        if (j === ((i - 1 + poly.length) % poly.length) || j === i || j === ((i + 1) % poly.length)) {
          continue;
        }
        if (isPointInTriangle(poly[j], prev, curr, next)) {
          return false;
        }
      }
      return true;
    }
    
    // Perform one ear clipping step: find an ear, clip it, and add the triangle to the results.
    function stepEarClipping() {
      if (polygon.length < 3) {
        alert("Triangulation complete!");
        return;
      }
      // If only a triangle remains, add it as the final triangle.
      if (polygon.length === 3) {
        triangles.push([...polygon]);
        polygon = [];
        draw();
        return;
      }
      
      // Find the first ear in the polygon.
      let earIndex = -1;
      for (let i = 0; i < polygon.length; i++) {
        if (isEar(i, polygon)) {
          earIndex = i;
          break;
        }
      }
      
      if (earIndex === -1) {
        alert("No ear found. The polygon might be self-intersecting.");
        return;
      }
      
      // Identify the vertices of the ear.
      const prev = polygon[(earIndex - 1 + polygon.length) % polygon.length];
      const curr = polygon[earIndex];
      const next = polygon[(earIndex + 1) % polygon.length];
      
      // Save the ear triangle.
      triangles.push([prev, curr, next]);
      
      // Remove the ear vertex from the polygon.
      polygon.splice(earIndex, 1);
      
      // Redraw, highlighting the ear that was just clipped.
      draw({ prev, curr, next });
    }
    
    // Draw the current state of the visualization.
    // If earTriangle is provided, its outline is highlighted.
    function draw(earTriangle) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw completed triangles (fill with semi-transparent green)
      triangles.forEach(tri => {
        ctx.beginPath();
        ctx.moveTo(tri[0].x, tri[0].y);
        ctx.lineTo(tri[1].x, tri[1].y);
        ctx.lineTo(tri[2].x, tri[2].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
        ctx.fill();
        ctx.strokeStyle = "green";
        ctx.stroke();
      });
      
      // Draw the current polygon in blue.
      if (polygon.length > 0) {
        ctx.beginPath();
        ctx.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i++) {
          ctx.lineTo(polygon[i].x, polygon[i].y);
        }
        ctx.closePath();
        ctx.strokeStyle = "blue";
        ctx.stroke();
      }
      
      // Draw vertices as small black circles.
      polygon.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = "black";
        ctx.fill();
      });
      
      // If an ear triangle is passed, highlight it with a red outline.
      if (earTriangle) {
        ctx.beginPath();
        ctx.moveTo(earTriangle.prev.x, earTriangle.prev.y);
        ctx.lineTo(earTriangle.curr.x, earTriangle.curr.y);
        ctx.lineTo(earTriangle.next.x, earTriangle.next.y);
        ctx.closePath();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.lineWidth = 1;
      }
    }
    
    // Bind the step function to the "Next Step" button.
    document.getElementById("nextStep").addEventListener("click", stepEarClipping);
  </script>
</body>
</html>
