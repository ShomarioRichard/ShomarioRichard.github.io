<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Freehand Draw with Snapping, Validation & Step-by-Step Ear Clipping</title>
  <style>
    canvas {
      border: 1px solid #ccc;
      margin-bottom: 10px;
      cursor: crosshair;
    }
    #controls button {
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <canvas id="canvas" width="600" height="400"></canvas>
  <div id="controls">
    <button id="clear">Clear</button>
    <button id="finishDrawing">Finish Drawing</button>
    <button id="nextStep">Next Step</button>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // Global state variables.
    let drawing = false;
    let originalPoints = []; // All freehand-drawn points.
    let polygon = [];        // The working polygon (closed when finished).
    let triangles = [];      // Completed triangles from ear clipping.
    let isSnapped = false;   // True if the mouse is within snapping distance.
    const snapThreshold = 10; // Distance (in pixels) to trigger snapping.

    // Start drawing on mousedown.
    canvas.addEventListener("mousedown", (e) => {
      drawing = true;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      originalPoints = [{ x, y }];
      polygon = [{ x, y }];
      isSnapped = false;
      draw();
    });

    // Record freehand points on mousemove.
    canvas.addEventListener("mousemove", (e) => {
      if (!drawing) return;
      const rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      let y = e.clientY - rect.top;
      // Check distance from the first point.
      const start = originalPoints[0];
      const dx = x - start.x;
      const dy = y - start.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < snapThreshold) {
        // Snap current point to the starting point.
        x = start.x;
        y = start.y;
        isSnapped = true;
      } else {
        isSnapped = false;
      }
      // Add the new point.
      originalPoints.push({ x, y });
      polygon.push({ x, y });
      draw();
    });

    // On mouseup, finish the drawingâ€”snapping if appropriate.
    canvas.addEventListener("mouseup", () => {
      drawing = false;
      if (polygon.length > 2) {
        if (isSnapped) {
          // Replace the last point with the starting point.
          polygon[polygon.length - 1] = polygon[0];
        } else {
          // Otherwise, explicitly close the polygon.
          polygon.push(polygon[0]);
        }
      }
      draw();
    });

    // "Finish Drawing" button forces closing the polygon.
    document.getElementById("finishDrawing").addEventListener("click", () => {
      if (polygon.length > 2 &&
         (polygon[0].x !== polygon[polygon.length - 1].x ||
          polygon[0].y !== polygon[polygon.length - 1].y)) {
        polygon.push(polygon[0]);
      }
      drawing = false;
      draw();
    });

    // --- Geometry Helpers for Ear Clipping and Validity Checks ---

    // Compute the signed area of triangle (p, q, r)
    function area(p, q, r) {
      return (q.x - p.x) * (r.y - p.y) - (r.x - p.x) * (q.y - p.y);
    }

    // Check if the angle at 'curr' is convex.
    function isConvex(prev, curr, next) {
      return area(prev, curr, next) < 0;
    }

    // Check if point pt is inside triangle (v1, v2, v3).
    function isPointInTriangle(pt, v1, v2, v3) {
      const d1 = area(pt, v1, v2);
      const d2 = area(pt, v2, v3);
      const d3 = area(pt, v3, v1);
      const hasNeg = (d1 < 0) || (d2 < 0) || (d3 < 0);
      const hasPos = (d1 > 0) || (d2 > 0) || (d3 > 0);
      return !(hasNeg && hasPos);
    }

    // Determine if vertex at index i is an ear.
    // The polygon is expected to be closed (first point repeated at the end).
    function isEar(i, poly) {
      if (poly.length < 4) return false; // Need at least 3 unique vertices.
      const uniquePoly = poly.slice(0, poly.length - 1);
      const len = uniquePoly.length;
      const idx = i;
      const prev = uniquePoly[(idx - 1 + len) % len];
      const curr = uniquePoly[idx];
      const next = uniquePoly[(idx + 1) % len];

      if (!isConvex(prev, curr, next)) return false;

      // Ensure no other vertex lies inside the candidate ear.
      for (let j = 0; j < len; j++) {
        if (j === ((idx - 1 + len) % len) || j === idx || j === ((idx + 1) % len)) {
          continue;
        }
        if (isPointInTriangle(uniquePoly[j], prev, curr, next)) {
          return false;
        }
      }
      return true;
    }

    // --- Self-Intersection Check Helpers ---

    // Check if point q lies on segment pr.
    function onSegment(p, q, r) {
      return q.x <= Math.max(p.x, r.x) &&
             q.x >= Math.min(p.x, r.x) &&
             q.y <= Math.max(p.y, r.y) &&
             q.y >= Math.min(p.y, r.y);
    }

    // Find orientation of ordered triplet (p, q, r).
    // Returns 0 if collinear, 1 if clockwise, 2 if counterclockwise.
    function orientation(p, q, r) {
      const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
      if (val === 0) return 0;
      return (val > 0) ? 1 : 2;
    }

    // Check whether segments p1q1 and p2q2 intersect.
    function segmentsIntersect(p1, q1, p2, q2) {
      const o1 = orientation(p1, q1, p2);
      const o2 = orientation(p1, q1, q2);
      const o3 = orientation(p2, q2, p1);
      const o4 = orientation(p2, q2, q1);

      // General case.
      if (o1 !== o2 && o3 !== o4) return true;

      // Special Cases.
      if (o1 === 0 && onSegment(p1, p2, q1)) return true;
      if (o2 === 0 && onSegment(p1, q2, q1)) return true;
      if (o3 === 0 && onSegment(p2, p1, q2)) return true;
      if (o4 === 0 && onSegment(p2, q1, q2)) return true;

      return false;
    }

    // Check if a closed polygon (with duplicate start/end point) is self-intersecting.
    function isSelfIntersecting(poly) {
      // poly is expected to be closed.
      const n = poly.length - 1; // Last point is duplicate.
      for (let i = 0; i < n; i++) {
        const a = poly[i], b = poly[i + 1];
        for (let j = i + 1; j < n; j++) {
          // Skip adjacent edges (they share a vertex) and the first/last edge.
          if (j === i || j === i + 1) continue;
          if (i === 0 && j === n - 1) continue;
          const c = poly[j], d = poly[j + 1];
          if (segmentsIntersect(a, b, c, d)) return true;
        }
      }
      return false;
    }

    // --- Ear Clipping Step Function ---

    // Perform one ear clipping step.
    function stepEarClipping() {
      // Ensure we have a closed polygon.
      if (polygon.length < 4) {
        alert("Not enough points to triangulate.");
        return;
      }

      // Validate the polygon before clipping.
      if (isSelfIntersecting(polygon)) {
        alert("The drawn polygon is invalid: it is self-intersecting.");
        return;
      }

      // Work with unique vertices (exclude duplicate last point).
      let poly = polygon.slice(0, polygon.length - 1);

      // If only one triangle remains, add it and clear the working polygon.
      if (poly.length === 3) {
        triangles.push([...poly]);
        polygon = [];
        draw();
        return;
      }

      let earIndex = -1;
      for (let i = 0; i < poly.length; i++) {
        if (isEar(i, [...poly, poly[0]])) {
          earIndex = i;
          break;
        }
      }

      if (earIndex === -1) {
        alert("No ear found. The drawn region may be invalid.");
        return;
      }

      const prev = poly[(earIndex - 1 + poly.length) % poly.length];
      const curr = poly[earIndex];
      const next = poly[(earIndex + 1) % poly.length];
      triangles.push([prev, curr, next]);

      // Remove the ear vertex.
      poly.splice(earIndex, 1);
      // Rebuild the closed polygon.
      polygon = [...poly, poly[0]];
      draw({ prev, curr, next });
    }

    // --- Drawing Function ---

    // Draw the current state.
    // If earTriangle is provided, highlight it with a red outline.
    function draw(earTriangle) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw completed triangles in green.
      triangles.forEach(tri => {
        ctx.beginPath();
        ctx.moveTo(tri[0].x, tri[0].y);
        ctx.lineTo(tri[1].x, tri[1].y);
        ctx.lineTo(tri[2].x, tri[2].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(0, 255, 0, 0.3)";
        ctx.fill();
        ctx.strokeStyle = "green";
        ctx.stroke();
      });

      // Draw the current polygon in blue.
      if (polygon.length > 0) {
        ctx.beginPath();
        ctx.moveTo(polygon[0].x, polygon[0].y);
        for (let i = 1; i < polygon.length; i++) {
          ctx.lineTo(polygon[i].x, polygon[i].y);
        }
        ctx.strokeStyle = "blue";
        ctx.stroke();
      }

      // Draw the vertices as small black circles.
      polygon.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = "black";
        ctx.fill();
      });

      // Draw the snap zone indicator around the first point.
      if (originalPoints.length > 0) {
        ctx.beginPath();
        ctx.arc(originalPoints[0].x, originalPoints[0].y, snapThreshold, 0, Math.PI * 2);
        ctx.strokeStyle = "orange";
        ctx.setLineDash([5, 5]);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // If an ear triangle is provided, highlight it in red.
      if (earTriangle) {
        ctx.beginPath();
        ctx.moveTo(earTriangle.prev.x, earTriangle.prev.y);
        ctx.lineTo(earTriangle.curr.x, earTriangle.curr.y);
        ctx.lineTo(earTriangle.next.x, earTriangle.next.y);
        ctx.closePath();
        ctx.strokeStyle = "red";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.lineWidth = 1;
      }
    }

    // --- Event Bindings ---

    document.getElementById("nextStep").addEventListener("click", stepEarClipping);
    document.getElementById("clear").addEventListener("click", () => {
      originalPoints = [];
      polygon = [];
      triangles = [];
      drawing = false;
      isSnapped = false;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });
  </script>
</body>
</html>
