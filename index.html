<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Earcut Animation Visualization with Math Explanation</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
    }
    #container {
      display: flex;
      height: 100vh;
    }
    #left-panel {
      flex: 2;
      padding: 10px;
      box-sizing: border-box;
    }
    #right-panel {
      flex: 1;
      padding: 10px;
      background-color: #f4f4f4;
      border-left: 1px solid #ccc;
      box-sizing: border-box;
      overflow-y: auto;
    }
    canvas {
      border: 1px solid #ccc;
      margin-bottom: 10px;
      display: block;
    }
    #controls button {
      margin-right: 5px;
      margin-bottom: 5px;
    }
    h2, h3 {
      margin-top: 0;
    }
    pre {
      background: #eee;
      padding: 8px;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="left-panel">
      <canvas id="canvas" width="600" height="400"></canvas>
      <div id="controls">
        <button id="clear">Clear</button>
        <button id="animate">Animate Triangulation</button>
      </div>
    </div>
    <div id="right-panel">
      <h2>Algorithm Explanation</h2>
      <div id="details">
        <p>Click on the canvas to define your polygon. When you're ready, click "Animate Triangulation" to see the ear clipping algorithm in action.</p>
        <h3>Mathematical Foundations</h3>
        <p>
          The ear clipping algorithm is a method for decomposing a simple polygon into triangles. It works by iteratively removing "ears"—triangles that can be cut off without affecting the integrity of the polygon.
        </p>
        <h4>1. Polygon Orientation and Signed Area</h4>
        <p>
          To determine the order of the vertices, the algorithm computes the signed area of the polygon:
        </p>
        <pre>
A = (1/2) * Σ (x[i]*y[i+1] - x[i+1]*y[i])
        </pre>
        <p>
          A positive area indicates a counterclockwise (CCW) orientation, while a negative area indicates clockwise (CW). This orientation is crucial for later determining whether a vertex forms a convex angle.
        </p>
        <h4>2. Checking Convexity with the Cross Product</h4>
        <p>
          For any three consecutive vertices A, B, and C, the convexity at vertex B is determined by the cross product of the vectors AB and BC:
        </p>
        <pre>
cross = (B.x - A.x)*(C.y - B.y) - (B.y - A.y)*(C.x - B.x)
        </pre>
        <p>
          For a CCW polygon, a positive cross product indicates that the angle at B is convex. In a CW polygon, the condition is reversed. Only convex vertices can serve as the middle vertex of an "ear."
        </p>
        <h4>3. Identifying an Ear Using a Point-in-Triangle Test</h4>
        <p>
          Once a vertex is identified as convex, the triangle formed by it and its two neighbors is considered a candidate ear. However, for the triangle to be a valid ear, no other vertex of the polygon should lie inside it. This is often checked using a point-in-triangle test:
        </p>
        <pre>
sign(P, V1, V2) = (P.x - V2.x) * (V1.y - V2.y) - (V1.x - V2.x) * (P.y - V2.y)
        </pre>
        <p>
          A point P is inside the triangle (V1, V2, V3) if the signs of sign(P, V1, V2), sign(P, V2, V3), and sign(P, V3, V1) are all the same.
        </p>
        <h4>4. Clipping the Ear</h4>
        <p>
          When an ear is found, its central vertex is removed from the polygon, and the ear (the triangle) is added to the list of finalized triangles. The polygon is then updated, and the process repeats until the entire polygon is decomposed.
        </p>
        <h4>5. Why It Works</h4>
        <p>
          Mathematically, it has been proven that every simple polygon has at least two ears. By repeatedly clipping these ears, the algorithm guarantees that the polygon will eventually be fully triangulated. While the worst-case performance is O(n²) for n vertices, the approach is simple and robust for many practical applications.
        </p>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const detailsEl = document.getElementById("details");
    // Store vertices as objects: {x, y}
    let points = [];

    // Capture user clicks to define the polygon.
    canvas.addEventListener("click", (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      points.push({ x, y });
      drawAll(points, []);  // redraw current polygon
      updateDetails(`<p>Added point at (${x.toFixed(0)}, ${y.toFixed(0)}). Total points: ${points.length}.</p>`);
    });

    // Function to update the explanation panel.
    function updateDetails(message) {
      detailsEl.innerHTML += message;
      detailsEl.scrollTop = detailsEl.scrollHeight;
    }

    // Draw the complete scene:
    // - finalized triangles (filled green)
    // - current polygon (outlined in gray)
    // - vertices (black circles)
    // - an optional highlighted ear (in red)
    function drawAll(currentPoly, triangles, highlightEar = null) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw finalized triangles (filled green)
      triangles.forEach(tri => {
        ctx.beginPath();
        ctx.moveTo(tri[0].x, tri[0].y);
        ctx.lineTo(tri[1].x, tri[1].y);
        ctx.lineTo(tri[2].x, tri[2].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(0, 128, 0, 0.3)"; // semi-transparent green
        ctx.fill();
        ctx.strokeStyle = "green";
        ctx.stroke();
      });

      // Draw current polygon edges
      if (currentPoly.length) {
        ctx.beginPath();
        ctx.moveTo(currentPoly[0].x, currentPoly[0].y);
        for (let i = 1; i < currentPoly.length; i++) {
          ctx.lineTo(currentPoly[i].x, currentPoly[i].y);
        }
        if (currentPoly.length > 2) {
          ctx.closePath();
        }
        ctx.strokeStyle = "#999";
        ctx.stroke();
      }

      // Draw vertices as black circles.
      currentPoly.forEach(pt => {
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
        ctx.fillStyle = "black";
        ctx.fill();
      });

      // If provided, highlight the current ear in semi-transparent red.
      if (highlightEar) {
        ctx.beginPath();
        ctx.moveTo(highlightEar[0].x, highlightEar[0].y);
        ctx.lineTo(highlightEar[1].x, highlightEar[1].y);
        ctx.lineTo(highlightEar[2].x, highlightEar[2].y);
        ctx.closePath();
        ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
        ctx.fill();
        ctx.strokeStyle = "red";
        ctx.stroke();
      }
    }

    // Helper: compute signed area to determine polygon orientation.
    function signedArea(poly) {
      let area = 0;
      for (let i = 0; i < poly.length; i++) {
        const j = (i + 1) % poly.length;
        area += poly[i].x * poly[j].y - poly[j].x * poly[i].y;
      }
      return area / 2;
    }

    // Helper: check if vertex b (with neighbors a and c) is convex.
    function isConvex(a, b, c, isCCW) {
      // Cross product of vectors (b - a) and (c - b)
      let cross = (b.x - a.x) * (c.y - b.y) - (b.y - a.y) * (c.x - b.x);
      return isCCW ? (cross > 0) : (cross < 0);
    }

    // Helper: check if point pt is inside triangle (v1, v2, v3).
    function pointInTriangle(pt, v1, v2, v3) {
      function sign(p1, p2, p3) {
        return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);
      }
      let b1 = sign(pt, v1, v2) < 0;
      let b2 = sign(pt, v2, v3) < 0;
      let b3 = sign(pt, v3, v1) < 0;
      return (b1 === b2) && (b2 === b3);
    }

    // Animate the ear-clipping (triangulation) process.
    function earClippingAnimation() {
      if (points.length < 3) {
        alert("Please define a polygon with at least 3 points.");
        return;
      }
      // Clear previous details.
      detailsEl.innerHTML = "";
      updateDetails("<p><strong>Starting ear clipping process.</strong></p>");

      // Make a working copy of the polygon.
      let poly = points.slice();
      let triangles = [];
      let isCCW = signedArea(poly) > 0;
      updateDetails(`<p>Polygon has ${poly.length} vertices and is oriented ${isCCW ? "counterclockwise" : "clockwise"}.</p>`);

      // Helper functions to get neighbor indices.
      function nextIndex(i) { return (i + 1) % poly.length; }
      function prevIndex(i) { return (i - 1 + poly.length) % poly.length; }

      // Find the first "ear" in the current polygon.
      function findEar() {
        for (let i = 0; i < poly.length; i++) {
          let prev = poly[prevIndex(i)];
          let curr = poly[i];
          let next = poly[nextIndex(i)];
          if (!isConvex(prev, curr, next, isCCW)) continue;
          // Ensure no other vertex is inside the triangle.
          let earFound = true;
          for (let j = 0; j < poly.length; j++) {
            if (j === i || j === prevIndex(i) || j === nextIndex(i)) continue;
            if (pointInTriangle(poly[j], prev, curr, next)) {
              earFound = false;
              break;
            }
          }
          if (earFound) {
            updateDetails(`<p>Ear found at vertex ${i} with points: (${prev.x.toFixed(0)}, ${prev.y.toFixed(0)}), (${curr.x.toFixed(0)}, ${curr.y.toFixed(0)}), (${next.x.toFixed(0)}, ${next.y.toFixed(0)}).</p>`);
            return { earIndex: i, ear: [prev, curr, next] };
          }
        }
        return null;
      }

      // Process one ear-clipping step.
      function step() {
        if (poly.length <= 3) {
          // Last remaining triangle.
          if (poly.length === 3) {
            triangles.push(poly.slice());
            updateDetails(`<p>Final triangle formed with points: (${poly[0].x.toFixed(0)}, ${poly[0].y.toFixed(0)}), (${poly[1].x.toFixed(0)}, ${poly[1].y.toFixed(0)}), (${poly[2].x.toFixed(0)}, ${poly[2].y.toFixed(0)}).</p>`);
          }
          drawAll([], triangles);
          updateDetails("<p><strong>Triangulation complete!</strong></p>");
          return;
        }
        let earData = findEar();
        if (!earData) {
          updateDetails("<p>No ear found. The polygon may be non-simple.</p>");
          drawAll(poly, triangles);
          return;
        }
        let earIndex = earData.earIndex;
        let ear = earData.ear;
        // Highlight the ear.
        drawAll(poly, triangles, ear);
        updateDetails("<p>Highlighting the ear. Waiting 500ms before clipping it...</p>");
        // Pause to show the highlighted ear, then clip it.
        setTimeout(() => {
          // Remove the ear's vertex (the middle one).
          let removed = poly.splice(earIndex, 1)[0];
          triangles.push(ear);
          updateDetails(`<p>Clipped ear at (${removed.x.toFixed(0)}, ${removed.y.toFixed(0)}). Ear added as a triangle. Remaining vertices: ${poly.length}.</p>`);
          // Redraw the scene and continue after a brief delay.
          drawAll(poly, triangles);
          setTimeout(step, 500);
        }, 500);
      }
      step();
    }

    document.getElementById("clear").addEventListener("click", () => {
      points = [];
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      detailsEl.innerHTML = "<p>Canvas cleared. Click on the canvas to add points.</p>";
    });

    document.getElementById("animate").addEventListener("click", () => {
      earClippingAnimation();
    });
  </script>
</body>
</html>
